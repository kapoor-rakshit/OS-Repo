1. Initialization phase to set up the environment.

The shell checks to see whether the file /etc/profile exists.
The shell checks to see whether the file .profile exists in your home directory. 

As soon as both of these files have been read, the shell displays a prompt − $

Each user intended to use UNIX system must have a login.
Each user has a unique USER ID (uid) assigned by system that can be found in   '/etc/passwd'   file.
NOTE : encrypted password is stored in                                         '/etc/shadow'   file.
Example: $ cat /etc/passwd
         user_name:password:user_id:group_id:user_info:home_dir:login_shell

A user can belong to more than one group.
Each group has a name and a unique GROUP ID (gid) that can be found in         '/etc/group'    file.
Example: $ cat /etc/group
         group_name:password:group_id:group_list
         
      
Some important file/directories
- /bin            : contains commonly used executables such as cat, date, grep
- /usr/bin        : contains executables related to development tools - compilers such as gcc, make, man
- /usr/sbin       : contains executables that can be run by super user or administrator only
- /usr/lib        : contains library files used by applications
- /etc            : contains shell script files and config files used by system boot
- /etc/passwd     : contains info about users who have account on UNIX machine
- /var/log        : hold system log files
- /dev            : contains device files
- /dev/null       : anything written to it never gets stored. Nothing can be read from it.
- /boot           : binary files of OS
- /proc           : files for state of system and processes
- /tmp            : holds temporary files generated by compilers and tools. It is emptied on each system boot up.


2. PS1 and PS2 Variables

The characters that the shell displays as your command prompt "$" default, are stored in the variable PS1.
You can change this variable by :
PS1=" <your symbol> "
PS1="\u@\h:\w\#$"                          //with escape sequences      example   \# to get count of commands

Escape Sequence & Description   :        https://www.tutorialspoint.com/unix/unix-environment.htm

The default secondary prompt is > (the greater than sign), but can be changed by re-defining the PS2 shell variable.
PS2=" <your symbol> "


3. env command

env
# It can be used to print a list of the current environment variables, or to run another program in a custom environment without modifying the current one.
example : $LOGNAME , $USER , $LANG , $SHELL, $PATH      more at : https://www.tutorialspoint.com/unix/unix-environment.htm

env --version                                           # Display version information and exit.


4. uptime command
   uptime tells you how long the system has been running.
   uptime gives a one-line display of the following information:
The current time
how long the system has been running
how many users are currently logged on
the system load averages for the past 1, 5, and 15 minutes.  as  03:59:57 up 20 days, 14:03, 1 user, load avg:0.13,0.07,0.15


5. Some hacks

ctrl + a   :   move to beginning of command on terminal
ctrl + e   :   move to end of command on terminal
alt + .    :   use args of prev command in history as args to current command, repeated press changes args.

6. set command

set -o           :   check status of shell options
set -o vi        :   -o : set on ,  editor mode as vi
set +o noclobber :   +o : set off , noclobber option used to prevent overwriting of files
set -x           :   -x : set on xtrace


7. export command
#  the export command marks an environment variable to be exported with any newly forked child processes and thus it allows a child process to inherit all marked variables.

export          :   view all the exported variables.
export -p       :   -p : view all exported variables on current shell
unset varname   :   unexport a variable


8. exit status
checked using `echo $?` the exit status of last command executed

0   : ok
1   : error
2   : wrong usage
126 : not executable...permission denied
127 : command not found


9. SHELL CONFIG
a file home/.bashrc found at HOME dir is to be configured for user defined settings of shell.
eg : echo "Today is `date`"


10. ALIAS NAMING
commands can be aliased with a simpler ver.

alias ..="cd .."              # "cd .." aliased as .. , here .. performs same as cd ..
unalias ..                    # remove alias name


11. HISTORY
~/.bash_history               # file contains history of all commands
!-n                           # execute nth command from history
!string                       # execute most recent command matching string as a substring or whole of command


12. FILE SYSTEMS in UNIX
Disk based    ufs, ext2, ext3   Unix File System, Extended File System
Distributed   nfs               Network File System
Pseudo        tmpfs, proc       Temporary File System, Process Access File System

ext2 File System
It has following four logical areas:
Boot block  - contains bootstrap code.
Super block - contains description about file system.
Inode block - contains inode entries which has attributes of files or directories they correspond to
Data block  - contains file content


13. UPDATE / UPGRADE
In short executing “sudo apt-get update” fetches you a list of packages for all of your repositories and PPA’s and make sure it is up to date. 
While “sudo apt-get upgrade” does an actual software upgrade.
a.  $ sudo apt-get update
update is used to resynchronize the package index files from their sources. 
The indexes of available packages are fetched from the location(s) specified in /etc/apt/sources.list. 
For example, when using a Debian archive, this command retrieves and scans the Packages.gz files, so that information about new and updated packages is available. 
An update should always be performed before an upgrade or dist-upgrade.

b.  $ sudo apt-get upgrade
upgrade is used to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt/sources.list. 
Packages currently installed with new versions available are retrieved and upgraded; 
under no circumstances are currently installed packages removed, or packages not already installed retrieved and installed.
New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version.
An update must be performed first so that apt-get knows that new versions of packages are available.

